const { join } = require('path');
const { promisify } = require('util');
const exec = promisify(cp.exec);

const TIMEOUT = 10e3;

/**
 * Allows for Flowcord to auto-update all inherited entities
 * @property {String} entityID
 * @property {String} entityPath
 * @property {String} updateIdentifier
 * @abstract
 */
class Updatable {
  constructor(basePath, entityID, updateIdentifier) {
    this.basePath = basePath;
    
    if (!entityID) {
      // entityID might be defined by plugin manager
      this.entityID = entityID;
    }
      this.entityPath = join(this.basePath, this.entityID);

    if (!updateIdentifier) {
      updateIdentifier = `${this.basePath.split(/[\\/]/).pop()}_${this.entityID}`;
    }
    this.updateIdentifier = updateIdentifier;

    this.__migrateIfNecessary();
  }

  /**
   * Returns whether the entity can be updated via git
   * @returns {Boolean}
   */
  isUpdatable() {
    return existsSync(join(this.basePath, this.entityID, '.git')) && !this.__shortCircuit;
  }

  /**
   * Returns whether the entity needs updating
   * @returns {Boolean}
   */
  async _checkForUpdates() {
    const abort = new AbortController();
    const timeout = setTimeout(() => {
      abort.abort();
      throw new Error('Timed out.');
    }, TIMEOUT);

    try {
      await exec('git fetch', {
        cwd: this.entityPath,
        signal: abort.signal
      });
      const gitStatus = await exec('git status -uno', {
        cwd: this.entityPath,
        signal: abort.signal
      }).then(({
        stdout
      }) => stdout.toString());

      clearTimeout(timeout);
      return gitStatus.includes('git pull');
    } catch (e) {
      clearTimeout(timeout);
      return false;
    }
  }

  /**
   * 
   * @param {Boolean} force 
   * @returns {Boolean}
   */
  async _update (force = false) {
    try {
      let command = 'git pull --ff-only';
      if (force) {
        const branch = await this.getBranch();
        command = `git reset --hard origin/${branch}`;
      }
      await exec(command, { cwd: this.entityPath }).then(({ stdout }) => stdout.toString());
      return true;
    } catch (e) {
      return false;
    }
  }

  /**
   * Fetches the git repository for this entity
   * @returns {Promise<String|null>}
   */
  async getGitRepo() {
    const abort = new AbortController();
    const timeout = setTimeout(() => {
      abort.abort();
      throw new Error('Timed out.');
    }, TIMEOUT);

    try {
      return await exec('git remote get-url origin', {
        cwd: this.entityPath,
        signal: abort.signal
      }).then((r) => {
        clearTimeout(timeout);
        return r.stdout.toString().match(/github\.com[:/]([\w-_]+\/[\w-_]+)/)[1];
      });
    } catch (e) {
      clearTimeout(timeout);
      console.warn('Failed to fetch git origin url; ignoring.')
      return null;
    }
  }

  /**
   * Fetches the current branch for this entity
   * @returns {Promise<String|null>}
   */
  async getBranch() {
    const abort = new AbortController();
    const timeout = setTimeout(() => {
      abort.abort();
      throw new Error('Timed out.');
    }, TIMEOUT);

    return exec('git branch', {
      cwd: this.entityPath,
      signal: abort.signal
    }).then(({
      stdout
    }) => {
      clearTimeout(timeout);
      return stdout.toString().split('\n').find(l => l.startsWith('*')).slice(2).trim();
    });
  }

  /**
   * Migrates the plugin to a new repo if required
   */
  async __migrateIfNecessary() {
    if (!this.isUpdatable()) {
      return;
    }

    const repo = await this.getGitRepo();
    if (!repo) {
      return;
    }

    const url = `https://github.com/${repo}`;
    const newUrl = await this.__followRedirects(url);
    if (!newUrl) {
      this.__shortCircuit = true;
    } else if (url !== newUrl) {
      console.debug('[Updater] Migrating %s to repository %s', this.entityID, newUrl);
      await exec(`git remote set-url origin "${newUrl}"`, {
        cwd: this.entityPath
      });
    }
  }

  async __followRedirects(url) {
    let code = -1;
    do {
      try {
        const res = await head(url);
        code = res.statusCode;
        if (code === 301 || code === 302) {
          url = res.headers.location;
        }
      } catch (e) {
        return false;
      }
    } while (code === 301 || code === 302);
    return url;
  }
}

module.exports = Updatable;